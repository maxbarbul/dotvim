# if
snippet if
	if (${1}) {
		${0}
	}
# if ... else
snippet ife
	if (${1}) {
		${2}
	} else {
		${0}
	}
# ES6 class definition
snippet class
	class ${1:ClassName} {
		constructor (${2:options}) {
			${0}
		}
	}
# ternary operator
snippet ?
	? ${1}: ${0}
# React element with closing tag
snippet <
	<${1}>${0}</$1>
# React self-closing element 
snippet </
	<${1} ${0} />
# switch
snippet switch
	switch (${1:expression}) {
		case '${3:case}':
			${4:// code}
			break;
		${5}
		default:
			${2:// code}
	}
# case
snippet case
	case '${1}':
		${2}
		break;
	${3}
# Class Method arrow function
snippet :=
	${1:method_name} = (${2:attribute}) => {
		${0}
	}
# Getter Method
snippet get
	get ${1:value}: function () {
		return this.${2:_$1}
	}
# Setter Method
snippet set
	set ${1:value}(${2:$1}) {
		this.${3:_$1} = $2
	}
# setTimeout function
snippet timeout
	setTimeout(function() {${3}}${2}, ${1:10});
# console.info
snippet ci
	// XXX DEBUG
	console.info(${1})${0}
# console.warn
snippet cw
	// XXX DEBUG
	console.warn(${1});
# console.time
snippet ct
	// XXX DEBUG
	console.time('${1}');
# console.log
snippet cl
	// XXX DEBUG
	console.log(${1});
# console.error
snippet ce
	console.error(${1});
# return
snippet ret
	return ${1:result}
# bind
snippet .b
	.bind(${1:null}${2:, })${3}
# for (property in object ) { ... }
snippet fori
	for (let ${1:prop} in ${2:Things}) {
		${3:$2[$1]}
	}
# array map
snippet .m
	.map(${1} =>${0})
# Arrow function
snippet =>
	=> {
		${0}
	}
# Arrow function
snippet (=>
	(${1:item}${2}) => $1.${3}
# Arrow function
snippet =>{
	(${1:item}) => {
		$1${0}
	}

# array filter
snippet .fil
	.filter((${1:item}${2:, index}${3:, array}) => {
		if (${4}) {
			return true;
		}

		return false;
	});
# hasOwnProperty
snippet has
	hasOwnProperty(${1})
# Object literal
snippet {
	{
		${0}
	}
# Array literal
snippet [
	[
		${0}
	]
# TODO comment 
snippet xxx
	// XXX TODO ${0}
# Object literal as argument
snippet ({
	 ({${0}})
# docstring
snippet /**
	/**
	 * ${1:description}
	 */
snippet @paro
	@param {Object} ${1:name} ${2:description}
	@param {${3:String}} ${1}.${4:name} ${5:description}
snippet @par
	@param {${1:type}} ${2:name} ${3:description}
snippet @ret
	@return {${1:type}} ${2:description}
snippet @me
	@method ${1}
# JSON.parse
snippet jsonp
	JSON.parse(${1:jstr});
# JSON.stringify
snippet jsons
	JSON.stringify(${1:object});
# self-defining function
snippet sdf
	const ${1:function_name} = function (${2:argument}) {
		${3:// initial code ...}

		$1 = function ($2) {
			${4:// main code}
		};
	}
# this.
snippet t
	this.${0}
# throw Error
snippet thr
	throw new Error('${0}');
snippet thro
	throw new Error('${0}');
snippet throw
	throw new Error('${0}');
# describe
snippet desc
	describe('${1}', () => {
		${0}
	});
# test
snippet it
	it('${1}', () => {
		${0}
	});
# test exception throwing
snippet itthr
	it('${1}', () => {
		const invalidArguments = [
			null,
			false,
			true,
			{},
			[],
			-100,
			0,
			100${4}
		];

		for (let i = 0; i < invalidArguments.length; i += 1) {
			assert.throws(
				function (arg) {
					${2}(arg);
				}.bind(this, invalidArguments[i]),
				Error,
				null,
				'Exception was not thrown ${3} equal to ' + invalidArguments[i]
			);
		}
	});

snippet component
	import * as React from "react";
	import {t} from "../../../common/locale";

	export default class ${1} extends React.PureComponent {
		static defaultProps = {
		};

		render() {
			${2}
		}
	}

# module.exports
snippet ex
	module.exports = ${0}

